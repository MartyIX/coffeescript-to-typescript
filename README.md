
Whitespacing will not be preserved.  For the most part the spacing should be good, but there will also be many times when you should move the positioning

Funky function signatures may not compile right away.  Rather than have them compile in to semantically equivalent JavaScript, (i.e. what the coffee compiler usually does,) they are often translated to approximate the TypeScript.  For example, ... varags arguments (splats) are compiled to the same in TypeScript, even though tsc rejects them in all but the last place.  Similarly, default parameters are translated to TypeScript default parameters, even though CoffeeScript lets you put them in any order, while TypeScript restricts you to putting optional parameters after all other parameters.  Lastly, there may be some expressions used as default parameter values that are not allowed in TypeScript.
This is done intentionally to force the code to move to idiomatic TypeScript, rather than just compile.

Many unnecessary return statements are generated.  These will typically be something like returning the results of a function that returns void, like `return console.log(...);`. In CoffeeScript, the last expression in a function is automatically returned, so in the generated code, a return is added at every last expression.  These, even where unnecessary or wrong-seeming, are 'correct,' and do not make the program wrong.  You should remove the extraneous and wrong-looking ones as part of code clean up.

TypeScript requires all members to be declared on a class, and will throw a compile-time error when you try to access a member that is not declared.  Because members are typically not declared in CoffeeScript, as part of the porting process, one of our tools looks at all the missing property errors tsc throws, and adds them to classes of the appropriate name.  However, some classes have the same name, so they will get each other's properties.  Additionally, we don't try to guess the types of the members, so you will have to manually add the appropriate types to them.  While doing so, remove members that do not seem to belong to the class.  tsc will tell you if you've made a mistake.

Bound methods are `us.bind(method, this);` in the constructor.  Typescript methods are unbound, and while TypeScript's lambdas (arrow functions) are binding, they are not used for methods.  For now, we are using the mechanism CoffeeScript uses in the JavaScript it generates, which is manually binding the methods in the constructor.  TypeScript may include support for bound methods in the future, but it would require a language change, so we're not going to wait for it.  The *best* way to do it in TypeScript at the very moment might be passing `(arg1, arg2) => this.actualCallback(arg1, arg2)` as the callback parameter, and leaving `actualCallback(arg1, arg2)` be an unbound method.

For (comprehensions and loops) have been converted to .filter(), .forEach(), and .map() where appropriate and straightforward.  However, in CoffeeScript, you can modify an object being looped over, while you may not be able to with .filter(), .forEach(), and .map().

TypeScript requires constructors to make calls to super in a constructor as the first statement, while CoffeeScript does not.  Calls to super are left in place; tsc will let you know it considers them wrong, and it is up to you to move them to appease TypeScript.

TypeScript does not allow you to export a subclass of an unexported class, while CoffeeScript does.  In files where a single class is exported, this may require manual fixing to export both classes.  However, you will then need to import the classes as import class = require("class").class (assuming the classname is the same as the modulename/filename) in all files that use it.  Luckily, tsc should be able to tell you when and where you're importing wrong.
